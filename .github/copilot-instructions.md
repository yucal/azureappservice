This repository is a small FastAPI service meant as a minimal, maintainable template. The file below gives focused, actionable guidance for AI coding agents working on this codebase.

Quick facts
- Language: Python (FastAPI + Pydantic).
- Entry module: `app/main.py` (factory `create_app()`; app object is `app`).
- Router layout: `app/api/v1/routes.py` (APIRouter with prefix `/v1`).
- Schemas: `app/schemas/dataschemas.py` (Pydantic v2 style models).
- Dependencies manifest (note typo): `app/requirments.txt` (use this file when installing deps).

How to run locally (developer/dev server)
- Create a virtualenv and install deps:
  - python -m venv .venv
  - source .venv/bin/activate
  - pip install -r app/requirments.txt
- Run the dev server (module path points at the FastAPI app object):
  - uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

Primary architecture and patterns (what to look for)
- `create_app()` in `app/main.py` builds and returns the FastAPI app and wires routers via `app.include_router(...)`. Changes to top-level routing should either update `create_app()` or follow the existing include pattern.
- Router files use `APIRouter` and set `prefix` and `tags`. Example: `app/api/v1/routes.py` defines `router = APIRouter(prefix="/v1", tags=["Data API"])` and registers endpoints on that router.
- Endpoints use Pydantic models for both input and response. Example: `@router.post("/echo", response_model=DataPayload)` returns the incoming `DataPayload` model directly.
- Pydantic usage: models live under `app/schemas/`. Models use Pydantic v2 conventions (`class Config` with `extra = "forbid"`, `Field(...)`, `schema_extra`). Respect existing validation choices (extra forbidden, fields with examples/constraints).

Project-specific conventions and gotchas
- Dependency file is named `requirments.txt` (misspelling). Do not assume `requirements.txt` exists unless you create/rename it.
- Keep the package import paths as package-relative (e.g., `from api.v1.routes import router as v1_router`) â€” the project expects to be run with the `app` package on PYTHONPATH (uvicorn module path `app.main:app` works).
- Validation: models set `extra = "forbid"`. If you add fields to schemas, update all endpoints and examples accordingly to avoid unexpected validation errors.
- Response models: endpoints often return Pydantic objects. Returning dicts or model instances is acceptable, but ensure they match `response_model` shapes.

Examples the agent can use or modify
- Add a new GET route in `app/api/v1/routes.py`:
  - Use `@router.get("/status")` and return a small dict or Pydantic model.
- Add a schema:
  - Create `class NewModel(BaseModel): ...` in `app/schemas/...` and import it in the router.
- Example curl to test the existing endpoint:
  - curl -X POST http://localhost:8000/v1/echo -H "Content-Type: application/json" -d '{"name":"Alice","age":30}'

What not to change without CI/dev verification
- Do not rename `app` package or change how `create_app()` exports `app` without updating launch commands.
- Do not change Pydantic major version constraints in `app/requirments.txt` without ensuring compatibility (this repo pins pydantic >=2.x).

Integration points and external deps
- FastAPI (web framework) and Uvicorn (ASGI server) are the primary runtime pieces. Pydantic v2 is used for validation and schema generation.

If you (the agent) add files
- Follow the existing package layout: API routers under `app/api/...`, schemas under `app/schemas/...`.
- Update `app/main.py` only to include new routers (via `app.include_router(...)`). Keep `create_app()` as the single factory.

When in doubt: run the dev server and hit `http://localhost:8000/docs` to inspect autogenerated OpenAPI and examples from the Pydantic models.

If anything in this file looks incomplete or you need more context (tests, CI, Python version), ask for the preferred Python version and whether to fix `requirments.txt` typo before editing workflows.
